(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{439:function(t,a,e){t.exports=e.p+"assets/img/-1471578859676.f8f47ae5.png"},440:function(t,a,e){t.exports=e.p+"assets/img/-1471578872510.0b92df7c.png"},610:function(t,a,e){"use strict";e.r(a);var r=e(2),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"写个自动寻路的贪吃蛇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写个自动寻路的贪吃蛇"}},[t._v("#")]),t._v(" 写个自动寻路的贪吃蛇")]),t._v(" "),a("h1",{attrs:{id:"写个自动寻路的贪吃蛇-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写个自动寻路的贪吃蛇-2"}},[t._v("#")]),t._v(" 写个自动寻路的贪吃蛇")]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("偶尔看到两年前写的贪吃蛇，当时没把自动寻路的算法写好，蛇容易挂，周末找了个时间把当年的坑填上，写了个不会挂的贪吃蛇。")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://runjs.cn/detail/q0w7il3b",target:"_blank",rel:"noopener noreferrer"}},[t._v("两年前的版本_点击查看"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("img",{attrs:{src:e(439),alt:"-1471578859676.png"}})]),t._v(" "),a("p",[a("a",{attrs:{href:"https://myfjdthink.github.io/snake/snakeAuto.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("这次更新的版本_点击查看"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("img",{attrs:{src:e(440),alt:"-1471578872510.png"}})]),t._v(" "),a("p",[t._v("代码比较简单，抛开 A* 算法的实现，整个 html 代码在 300 行以内~")]),t._v(" "),a("p",[t._v("源码 ：")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/myfjdthink/myfjdthink.github.io/blob/master/snake/snakeAuto.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/myfjdthink/myfjdthink.github.io/blob/master/snake/snakeAuto.html"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"原理说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理说明"}},[t._v("#")]),t._v(" 原理说明")]),t._v(" "),a("h3",{attrs:{id:"不死的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不死的方法"}},[t._v("#")]),t._v(" 不死的方法")]),t._v(" "),a("p",[t._v("首先要找出一个模式可以保持蛇不挂，这个模式就是")]),t._v(" "),a("p",[t._v("“跟着尾巴跑”")]),t._v(" "),a("p",[t._v("如果蛇头和蛇尾是可以连通的，那么就不会挂。")]),t._v(" "),a("p",[t._v("所以只要保证任意时刻蛇头和蛇尾能连通即可。")]),t._v(" "),a("p",[t._v("寻路的伪代码如下：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if(head to  flood){ // 蛇头能连通食物    模拟蛇吃到食物后的状态    if(newHead to tail){   // 吃到食物后还能连接尾巴 安全        eat flood    }  else {        // 吃到食物后无法连接尾巴 放弃        flow tail    }} else {    flow tail   // 跟着尾巴跑}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("在吃食物之前，需要模拟吃到食物后蛇的状态，判断此时蛇是否还能连接尾巴，由此决定是否吃掉食物。")]),t._v(" "),a("h3",{attrs:{id:"如何找到最短路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何找到最短路径"}},[t._v("#")]),t._v(" 如何找到最短路径")]),t._v(" "),a("p",[t._v("使用 A* 算法可以快速找到俩点之间的最短路径，网上找了个实现，就直接扒下来使用啦。")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://devpro.it/examples/astar/index2.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://devpro.it/examples/astar/index2.html"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"todo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#todo"}},[t._v("#")]),t._v(" TODO")]),t._v(" "),a("p",[t._v("目前只是实现了不死，在某些条件下，程序还是会陷入一个循环，这个有空在改进吧，欢迎提 PR。")])])}),[],!1,null,null,null);a.default=s.exports}}]);