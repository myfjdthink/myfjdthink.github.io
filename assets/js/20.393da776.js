(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{522:function(e,t,a){e.exports=a.p+"assets/img/-1460603225863.e603afaf.png"},523:function(e,t,a){e.exports=a.p+"assets/img/-1461553851743.576c5051.png"},524:function(e,t,a){e.exports=a.p+"assets/img/-1461553811915.0f6a3bbd.png"},525:function(e,t,a){e.exports=a.p+"assets/img/-1461553765122.09befe50.png"},526:function(e,t,a){e.exports=a.p+"assets/img/-1461554196807.081c7566.png"},645:function(e,t,a){"use strict";a.r(t);var r=a(2),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"node-性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-性能优化"}},[e._v("#")]),e._v(" Node 性能优化")]),e._v(" "),t("h2",{attrs:{id:"node-性能优化-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-性能优化-2"}},[e._v("#")]),e._v(" Node 性能优化")]),e._v(" "),t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("没有 profile 谈优化都是耍流氓，性能优化的大前提是 profile ，有数据才能找出程序慢在哪里了。")]),e._v(" "),t("p",[e._v("本篇文章主要介绍 Node 后端的性能优化，前端的同学可以看看 Chrome 的 devtools "),t("a",{attrs:{href:"https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"一、web-应用优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、web-应用优化"}},[e._v("#")]),e._v(" 一、Web 应用优化")]),e._v(" "),t("p",[e._v("性能的瓶颈往往在 IO")]),e._v(" "),t("h4",{attrs:{id:"io-层优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io-层优化"}},[e._v("#")]),e._v(" IO 层优化")]),e._v(" "),t("h5",{attrs:{id:"磁盘-io-为什么慢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#磁盘-io-为什么慢"}},[e._v("#")]),e._v(" 磁盘 IO 为什么慢")]),e._v(" "),t("p",[e._v("计算机里的常见 IO 有 ：")]),e._v(" "),t("ul",[t("li",[e._v("CPU 一二级缓存")]),e._v(" "),t("li",[e._v("内存")]),e._v(" "),t("li",[e._v("硬盘")]),e._v(" "),t("li",[e._v("网络\n硬盘的 IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 41000000/250 = 164000 倍。")])]),e._v(" "),t("p",[e._v("所有在一般应用中，优化要首先考虑数磁盘 IO , 通常也就是数据层的优化，说到数据库优化，很多人第一时间会想到加索引，但是什么加了索引查询会变快呢？索引要怎么加才合适呢？")]),e._v(" "),t("h5",{attrs:{id:"为什么索引快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么索引快"}},[e._v("#")]),e._v(" 为什么索引快")]),e._v(" "),t("p",[e._v("关于索引的原理可以看看这篇文章，"),t("a",{attrs:{href:"http://tech.meituan.com/mysql-index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("索引原理"),t("OutboundLink")],1),e._v("。索引快主要的原因是：")]),e._v(" "),t("ul",[t("li",[e._v("索引占用空间更小，可以有效减少磁盘 IO 次数。")]),e._v(" "),t("li",[e._v("索引可以使用方便快速查询的数据结构，如"),t("strong",[e._v("b+树")]),e._v("。")])]),e._v(" "),t("h5",{attrs:{id:"索引怎么加"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引怎么加"}},[e._v("#")]),e._v(" 索引怎么加")]),e._v(" "),t("p",[e._v("回到我们的主题，"),t("strong",[e._v("没有 profile 谈优化都是耍流氓")])]),e._v(" "),t("p",[e._v("以 mongo 为例，mongo 是带有慢查询功能的。")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/zhoujinyi/p/3566773.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MongoDB 查询优化分析"),t("OutboundLink")],1),e._v(" 这篇文章介绍了如何开启和使用 mongo 的慢查询功能。")]),e._v(" "),t("p",[e._v("开启慢查询收集功能后，使用 db.system.profile.find().pretty() 语句可以查询到哪些语句的查询比较慢。以下面这个查询语句为例：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('query new_koala.llbrandomredpackage query: { user_id: "56ddb33e23db696f89fdae2a", status: { $ne: 1 } }\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("查询条件是 user_id、status 两个，所以给这两个字段加上索引可以提高查询速度。")]),e._v(" "),t("p",[e._v("当然，如果 mongo 没有是先开启慢查询，扫描一下 mongo.log 也是个办法。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("grep '[0-9][0-9][0-9]ms' /var/log/mongodb/mongodb.log\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("这样就可以找出所有查询耗时大于100 ms 的记录。然后再对症下药即可。")]),e._v(" "),t("h5",{attrs:{id:"缓存大法好-有选择地用。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存大法好-有选择地用。"}},[e._v("#")]),e._v(" 缓存大法好，有选择地用。")]),e._v(" "),t("p",[e._v("上文有说到，内存 IO 比磁盘 IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached 等。")]),e._v(" "),t("p",[e._v("缓存效果显著，所以很多时候一谈到优化，很多人就会想到加缓存，但是使用缓存是有代价的，你需要维护缓存的更新和失效，这是个"),t("strong",[e._v("繁琐")]),e._v("的事情，用上了缓存后你会经常碰到缓存没有及时更新带来的问题。")]),e._v(" "),t("p",[e._v("重要的事情说多几遍：")]),e._v(" "),t("p",[t("strong",[e._v("缓存有副作用")])]),e._v(" "),t("p",[t("strong",[e._v("缓存有副作用")])]),e._v(" "),t("p",[t("strong",[e._v("缓存有副作用")])]),e._v(" "),t("p",[e._v("并不是所有数据都需要缓存，"),t("strong",[e._v("访问频率高，生成代价比较高")]),e._v("的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存。")]),e._v(" "),t("p",[e._v("而且缓存还有 "),t("strong",[e._v("缓存雪崩")]),e._v("、"),t("strong",[e._v("缓存穿透")]),e._v(" 等问题要解决。见 "),t("a",{attrs:{href:"http://www.cnblogs.com/fidelQuan/p/4543387.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("缓存穿透与缓存雪崩"),t("OutboundLink")],1)]),e._v(" "),t("h5",{attrs:{id:"静态文件缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态文件缓存"}},[e._v("#")]),e._v(" 静态文件缓存")]),e._v(" "),t("p",[e._v("静态文件如图片、js 文件等具有不变性，是非常适合做缓存的。")]),e._v(" "),t("p",[e._v("常见的静态文件缓存服务有 nginx、vanish 等。")]),e._v(" "),t("h4",{attrs:{id:"代码层面优化。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码层面优化。"}},[e._v("#")]),e._v(" 代码层面优化。")]),e._v(" "),t("h5",{attrs:{id:"合并查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并查询"}},[e._v("#")]),e._v(" 合并查询")]),e._v(" "),t("p",[e._v("在代码这一块，常做的事情是将多次的查询合并为一次，消灭 for 循环，实际上还是减少数据库查询。例如")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for user_id in userIds      var account = user_account.findOne(user_id)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("这类代码实际上可以改写成：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var user_account_map = {}   // 注意这个对象将会消耗大量内存。user_account.find(user_id in user_ids).forEach(account){    user_account_map[account.user_id] =  account}for user_id in userIds     var account = user_account_map[user_id]\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("这样就把 N 次的查询合并为一次。")]),e._v(" "),t("p",[e._v("实际上还是为了减少 IO。")]),e._v(" "),t("h4",{attrs:{id:"关于过早优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于过早优化"}},[e._v("#")]),e._v(" 关于过早优化")]),e._v(" "),t("p",[e._v("性能优化的工作做多了以后，往往会陷入一个什么都想着去优化的状态，这样就可能陷入过早优化的深坑中。")]),e._v(" "),t("p",[e._v("这里引用一下其他人的观点")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.zhihu.com/question/24282796",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.zhihu.com/question/24282796"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("img",{attrs:{src:a(522),alt:"-1460603225863.png"}})]),e._v(" "),t("h3",{attrs:{id:"二、内存泄露排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、内存泄露排查"}},[e._v("#")]),e._v(" 二、内存泄露排查")]),e._v(" "),t("p",[e._v("Node 是基于 V8 这个 js 引擎的，这里我们了解下 V8 里的内存相关的知识。")]),e._v(" "),t("h4",{attrs:{id:"v8-的-gc-垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-的-gc-垃圾回收机制"}},[e._v("#")]),e._v(" V8 的 GC 垃圾回收机制")]),e._v(" "),t("h5",{attrs:{id:"v8-的内存分代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-的内存分代"}},[e._v("#")]),e._v(" V8 的内存分代")]),e._v(" "),t("p",[e._v("在 V8 中，主要将内存分为新生代和老生代两代。新生代的对象为存活时间比较短的对象，老生代中的对象为存活时间较长的或常驻内存的对象。")]),e._v(" "),t("p",[e._v("+—+—+—+—————————-+")]),e._v(" "),t("p",[e._v("| 新生代 | 。。。。。。老生代 |")]),e._v(" "),t("p",[e._v("+—+—+—+—————————-+")]),e._v(" "),t("p",[e._v("默认情况下，新生代的内存最大值在 64 位系统和 32 位系统上分别为 32 MB 和 16 MB。V8 对内存的最大值在 64 位系统和 32 位系统上分别为 1464 MB 和 732 MB。")]),e._v(" "),t("p",[e._v("为什么这样分两代呢？是为了最优的 GC 算法。新生代的 GC 算法 Scavenge 速度快，但是不合适大数据量；老生代针使用 Mark-Sweep（标记清除） & Mark-Compact（标记整理） 算法，合适大数据量，但是速度较慢。分别对新旧两代使用更适合他们的算法来优化 GC 速度。")]),e._v(" "),t("p",[e._v("详情参见《深入浅出 nodejs》5.1 V8 的垃圾回收机制与内存限制")]),e._v(" "),t("h4",{attrs:{id:"v8-的-gc-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-的-gc-log"}},[e._v("#")]),e._v(" V8 的 GC log")]),e._v(" "),t("p",[e._v("在启动程序的时候添加 –trace_gc 参数，V8 在进行垃圾回收的时候，会将垃圾回收的信息打印出来：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("➜  $ node --trace_gc aa.js...[94036]       68 ms: Scavenge 8.4 (42.5) -> 8.2 (43.5) MB, 2.4 ms [allocation failure].[94036]       74 ms: Scavenge 8.9 (43.5) -> 8.9 (46.5) MB, 5.1 ms [allocation failure].[94036] Increasing marking speed to 3 due to high promotion rate[94036]       85 ms: Scavenge 16.1 (46.5) -> 15.7 (47.5) MB, 3.8 ms (+ 5.0 ms in 106 steps since last GC) [allocation failure].[94036]       95 ms: Scavenge 16.7 (47.5) -> 16.6 (54.5) MB, 7.2 ms (+ 1.3 ms in 14 steps since last GC) [allocation failure].[94036]      111 ms: Mark-sweep 23.6 (54.5) -> 23.2 (54.5) MB, 6.2 ms (+ 15.3 ms in 222 steps since start of marking, biggest step 0.3 ms) [GC interrupt] [GC in old space requested]....\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("V8 提供了很多程序启动选项：")]),e._v(" "),t("p",[e._v("|–max-stack-size|设置栈大小                |\n|–v8-options    |打印 V8 相关命令          |\n|–trace-bailout |查找不能被优化的函数，重写|\n|–trace-deopt   |查找不能优化的函数        |")]),e._v(" "),t("h4",{attrs:{id:"使用-memwatch-模块来检测内存泄露"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-memwatch-模块来检测内存泄露"}},[e._v("#")]),e._v(" 使用 memwatch 模块来检测内存泄露")]),e._v(" "),t("p",[e._v("npm模块 memwatch 是一个非常好的内存泄漏检查工具，让我们先将这个模块安装到我们的app中去，执行以下命令：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install --save memwatch\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("然后，在我们的代码中，添加：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var memwatch = require('memwatch');\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("然后监听 leak 事件")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("memwatch.on('leak', function(info) { console.error('Memory leak detected: ', info);});\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("这样当我们执行我们的测试代码，我们会看到下面的信息：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{ start: Fri Jan 02 2015 10:38:49 GMT+0000 (GMT), end: Fri Jan 02 2015 10:38:50 GMT+0000 (GMT), growth: 7620560, reason: 'heap growth over 5 consecutive GCs (1s) - -2147483648 bytes/hr'}mem\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("memwatch 发现了内存泄漏！memwatch 判定内存泄漏事件发生的规则如下：")]),e._v(" "),t("p",[t("strong",[e._v("当你的堆内存在5个连续的垃圾回收周期内保持持续增长，那么一个内存泄漏事件被派发")])]),e._v(" "),t("p",[e._v("了解更加详细的内容，查看 "),t("a",{attrs:{href:"https://www.npmjs.com/package/memwatch",target:"_blank",rel:"noopener noreferrer"}},[e._v("memwatch"),t("OutboundLink")],1)]),e._v(" "),t("h4",{attrs:{id:"使用-heapdump-dump-出-node-应用内存快照"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-heapdump-dump-出-node-应用内存快照"}},[e._v("#")]),e._v(" 使用 heapdump dump 出 Node 应用内存快照")]),e._v(" "),t("p",[e._v("检测到了内存泄露的时候，我们需要查看当时内存的状态，heapdump 可以抓下当时内存的快照。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("memwatch.on('leak', function(info) { console.error(info); var file = '/tmp/myapp-' + process.pid + '-' + Date.now() + '.heapsnapshot'; heapdump.writeSnapshot(file, function(err){   if (err) console.error(err);   else console.error('Wrote snapshot: ' + file);  });});\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("运行我们的代码，磁盘上会产生一些 .heapsnapshot 的文件到/tmp目录下。")]),e._v(" "),t("h4",{attrs:{id:"使用-chrome-的开发者工具分析内存消耗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-chrome-的开发者工具分析内存消耗"}},[e._v("#")]),e._v(" 使用 Chrome 的开发者工具分析内存消耗")]),e._v(" "),t("p",[e._v("heapdump 提供的内存快照是可以用 Chrome 的开发者工具来查看的。把 .heapsnapshot 文件导入到 Chrome Developer Tools")]),e._v(" "),t("p",[t("img",{attrs:{src:a(523),alt:"-1461553851743.png"}})]),e._v(" "),t("p",[t("img",{attrs:{src:a(524),alt:"-1461553811915.png"}})]),e._v(" "),t("p",[e._v("怎么使用内存分析工具呢？")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.open-open.com/lib/view/open1421734578984.html#_label13",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chrome开发者工具之JavaScript内存分析"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("这篇文件详细介绍了如何使用开发者工具来分析内存的使用情况。可以参考，这里就不细说了。")]),e._v(" "),t("p",[e._v("摘取个例子，使用对比视图。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://developer.chrome.com/devtools/docs/heap-profiling-comparison",target:"_blank",rel:"noopener noreferrer"}},[e._v("对比视图 demo"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("这个例子展示了通过对比前后的内存变化来找出内存泄露的原因，看起来还是很简单方便的。")]),e._v(" "),t("p",[e._v("但是，理想很美好，现实很残酷。下面展示下日常开发中 dump 下的数据。")]),e._v(" "),t("p",[e._v("使用对比视图：")]),e._v(" "),t("p",[e._v("可以看出 array 是内存增长的主要元凶，但也只能得到这个线索，那具体是那些 array 消耗了内存呢？")]),e._v(" "),t("p",[e._v("点开 array 查看详细信息："),t("img",{attrs:{src:a(525),alt:"-1461553765122.png"}})]),e._v(" "),t("p",[e._v("一大堆的匿名数组，无法准确查到具体那些 array 消耗了内存。")]),e._v(" "),t("p",[e._v("主要原因是后端使用了 sails 这个 web 框架，框架里的代码量比较多，干扰项太多，无法准确地判断是哪些 function 出现了问题。"),t("img",{attrs:{src:a(526),alt:"-1461554196807.png"}})]),e._v(" "),t("h4",{attrs:{id:"内存泄露原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露原因"}},[e._v("#")]),e._v(" 内存泄露原因")]),e._v(" "),t("p",[e._v("通常，造成内存泄露的原因有如下几个。")]),e._v(" "),t("ul",[t("li",[e._v("慎用内存当缓存，非用的话控制好缓存的大小和过期时间，防止出现永远无法释放的问题")]),e._v(" "),t("li",[e._v("队列消费不及时，数组、回调，生产者的速度比消费者速度快，堆积了大量生产者导致无法释放作用域或变量")]),e._v(" "),t("li",[e._v("作用域未释放，无法立即回收的内存有全局变量和闭包，尽量使用变量赋值为 null|undefined 来触发回收\n这部分的详细解释请参考《深入浅出 nodejs》5.4 内存泄露。")])]),e._v(" "),t("h3",{attrs:{id:"三、优化应用-cpu-瓶颈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、优化应用-cpu-瓶颈"}},[e._v("#")]),e._v(" 三、优化应用 CPU 瓶颈")]),e._v(" "),t("p",[e._v("上面介绍了 IO 优化，内存优化，使用 Node 做后端的话还会经常碰到 CPU 瓶颈。总所周知，Node 是单线程的，所以对 CPU 密集的运算不是太胜任，所以应该避免使用 Node 来进行 CPU 密集的运算。")]),e._v(" "),t("p",[e._v("那么如果出现了 CPU 类的问题要怎么处理呢？")]),e._v(" "),t("h4",{attrs:{id:"v8log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8log"}},[e._v("#")]),e._v(" V8log:")]),e._v(" "),t("p",[e._v("加入 –prof 参数可以在应用结束是收集 log，执行命令之后，会在该目录下产生一个 *-v8.log 的日志文件，我们可以安装一个日志分析工具 tick")]),e._v(" "),t("h4",{attrs:{id:"tick-工具分析-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tick-工具分析-log"}},[e._v("#")]),e._v(" tick 工具分析 log")]),e._v(" "),t("p",[e._v("可以分析每个 function 的处理时间。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("➜  $ sudo npm install tick -g➜  $ node-tick-processor *-v8.log[Top down (heavy) profile]:  Note: callees occupying less than 0.1% are not shown.  inclusive      self           name  ticks   total  ticks   total    426   36.7%      0    0.0%  Function: ~<anonymous> node.js:27:10    426   36.7%      0    0.0%    LazyCompile: ~startup node.js:30:19    410   35.3%      0    0.0%      LazyCompile: ~Module.runMain module.js:499:26    409   35.2%      0    0.0%        LazyCompile: Module._load module.js:273:24    407   35.1%      0    0.0%          LazyCompile: ~Module.load module.js:345:33    406   35.0%      0    0.0%            LazyCompile: ~Module._extensions..js module.js:476:37    405   34.9%      0    0.0%              LazyCompile: ~Module._compile module.js:378:37...\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("前端的同学可以直接在 chrome 里收集 cpu profile 用于分析。")]),e._v(" "),t("h3",{attrs:{id:"使用第三方平台"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用第三方平台"}},[e._v("#")]),e._v(" 使用第三方平台")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://alinode.aliyun.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("alinode"),t("OutboundLink")],1),e._v("，基于 Node 运行时的应用性能管理解决方案，笔者没有体验过，不预评价。")]),e._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("文章主要介绍的还是后端开发中如何做性能优化的几种方式：")]),e._v(" "),t("ul",[t("li",[e._v("添加索引")]),e._v(" "),t("li",[e._v("接口缓存")]),e._v(" "),t("li",[e._v("静态文件缓存")]),e._v(" "),t("li",[e._v("合并查询")])]),e._v(" "),t("p",[e._v("这几种方法的目的其实都是为了减少 IO。看来 IO 过高是 Node 应用反应慢的主要原因。\n此外，文章也介绍了如何排查处理内存泄露和 CPU 过高的问题。这两类问题是也是影响 Node 性能的一大原因。")]),e._v(" "),t("h3",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考：")]),e._v(" "),t("p",[e._v("《深入浅出 nodejs》朴灵著")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://tech.meituan.com/mysql-index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MySQL索引原理及慢查询优化"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/zhoujinyi/p/3566773.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MongoDB 查询优化分析"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.zhihu.com/question/27738066",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何用redis/memcache做Mysql缓存层?"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/fidelQuan/p/4543387.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("缓存穿透与缓存雪崩"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line/"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.w3ctech.com/topic/842",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.w3ctech.com/topic/842"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://m.oschina.net/blog/270248",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://m.oschina.net/blog/270248"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.cnblogs.com/constantince/p/4607497.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.cnblogs.com/constantince/p/4607497.html"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.open-open.com/lib/view/open1421734578984.html#_label13",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.open-open.com/lib/view/open1421734578984.html#_label13"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);